[TOC]



# 超级电容



## 控制逻辑

分两种情况

1. 不使用超级电容：
   不使用的时候，使用pid，通过控制`gain`使超级电容电压稳定在固定数值
2. 使用超级电容：
   目前方案是根据实际情况提高 `gain` 的数值



## 接收



### 接收数据结构体

```c
typedef struct
{		
	float input_voltage;  //输入电压
	float Capacitance_voltage;  //电容电压
	float Input_current;  //输入电流
	float Set_power;  //设定功率
} Supercapacitor_receive_t;

Supercapacitor_receive_t Supercap_receive;
```



### 接收数据函数

```c
/**
  * @brief          超级电容can接收函数
  * @param[in]      none
  * @retval         none
  * @attention      在can接收中断中调用
  */
static void can1_receive(CanRxMsg *rx_message)
{
    switch (rx_message->StdId)
    {
		case 0x211: //超级电容接收
		{
			uint16_t *cap_redata = (uint16_t *)rx_message->Data;
			Supercap_receive.input_voltage = (float)(cap_redata[0] / 100.0f);
			Supercap_receive.Capacitance_voltage = (float)(cap_redata[1] / 100.0f);
			Supercap_receive.Input_current = (float)(cap_redata[2] / 100.0f);
			
			Supercap_receive.Set_power = (float)(cap_redata[3] / 100.0f);
			break;
		}
		
		default:
			break;
    }
}
```





## 发送



**！！！发送频率控制在10Hz左右！！！**



### can发送函数

```c
void can1_cap_setmsg(int16_t Chassis_power)
{
    uint8_t mbox;
    uint16_t i = 0;
    CanTxMsg CAN1_TxMessage; //定义一个发送信息的结构体
	
	Chassis_power = Chassis_power * 100;

    CAN1_TxMessage.StdId = 0x210;       //根据820r设置标识符
    CAN1_TxMessage.IDE = CAN_ID_STD;    //指定将要传输的消息的标识符的类型
    CAN1_TxMessage.RTR = CAN_RTR_DATA;  //指定的帧将被传输的消息的类型   数据帧或远程帧
    CAN1_TxMessage.DLC = 2;             // 发送两帧信息
	
    CAN1_TxMessage.Data[0] = (uint8_t)(Chassis_power >> 8);
    CAN1_TxMessage.Data[1] = (uint8_t)(Chassis_power);

    mbox = CAN_Transmit(CAN1, &CAN1_TxMessage); //发送信息
    i = 0;
    while ((CAN_TransmitStatus(CAN1, mbox) == CAN_TxStatus_Failed) && (i < 0XFFF)) //等待发送结束
        i++;
}
```





### 创建软件定时器

```c
TimerHandle_t CAP_Timer_Handle; //周期定时器句柄

/**
  * @brief          软件定时器创建函数
  * @param[in]      none
  * @retval         none
  * @attention      
  */
void timer_send_create(void)
{
    taskENTER_CRITICAL(); //进入临界区


    //创建can1发送定时器
    CAP_Timer_Handle = xTimerCreate((const char *)"CAP_Timer",
                                     (TickType_t)100,                               //10Hz - 100ms一次
                                     (UBaseType_t)pdTRUE,                           //周期执行
                                     (void *)0,                                     //编号一般给0
                                     (TimerCallbackFunction_t)CAP_Timer_Callback);  //回调函数

    //开启定时器,仅且仅能开启一次，否则会出错，不开启则不会发数据
    if (CAP_Timer_Handle != NULL)
    {
        xTimerStart(CAP_Timer_Handle, 0); //不等待
    }


    taskEXIT_CRITICAL(); //退出临界区
}
```



### 软件定时器回调函数

```c
/**
  * @brief          软件定时回调函数
  * @param[in]      none
  * @retval         none
  * @attention      禁用delay
  */
void CAP_Timer_Callback(TimerHandle_t xTimer)
{
    /* 函数主体 - 10Hz频率调用 */
	uint16_t power = referee_chassis_power_limit();
	if (power >= 50 && power <= 120)
	{
		can1_cap_setmsg(power);
	}
	else
	{
		can1_cap_setmsg(80);
	}
}
```





### 在主函数调用

```c
timer_send_create();    //创建软件定时器
```



## 功率限制

```c
/**
  * @brief          底盘功率限制
  * @param[in]      *chassis_power_limit_f：底盘主结构体
  * @retval         none
  */
extern Supercapacitor_receive_t Supercap_receive;
void chassis_power_limit_control_2(chassis_control_t *chassis_pl_f)
{
	if (chassis_pl_f->SuperCap_discharge_flag == 1)
	{
		chassis_pl_f->chassis_speed_gain = (referee_chassis_power_limit() / 5.0f) * 1.1f;
	}
	else
	{
		if (Supercap_receive.Capacitance_voltage > 12.0f)
		{
			uint16_t power = referee_chassis_power_limit();
			
			chassis_pl_f->chassis_power_pid.SetValue = 19.5f; //不使用超级电容的时候，使电容电压稳定在19.5f
			increment_pid(&chassis_pl_f->chassis_power_pid, Supercap_receive.Capacitance_voltage);
			
			chassis_pl_f->chassis_speed_gain += -chassis_pl_f->chassis_power_pid.out;
			
			if (power > 100 && power <= 120) //TODO 根据最大功率来选择 gain参数的限制范围
			{
				chassis_pl_f->chassis_speed_gain = float_limit(chassis_pl_f->chassis_speed_gain, 24.0f, 10.0f);
			}
			else
			{
				chassis_pl_f->chassis_speed_gain = float_limit(chassis_pl_f->chassis_speed_gain, 18.0f, 3.0f);
			}
			//简单的滤波
			chassis_pl_f->chassis_speed_gain = (1-0.04f) * chassis_pl_f->chassis_last_speed_gain + (0.04f) * chassis_pl_f->chassis_speed_gain;
			chassis_pl_f->chassis_last_speed_gain = chassis_pl_f->chassis_speed_gain;
		}
		else if (Supercap_receive.Capacitance_voltage == 0.0f)
		{
			chassis_pl_f->chassis_speed_gain = 8.0f;
		}
	}
}
```





## pid

```c
		pid_init(&chassis_move_init_f->chassis_power_pid, 100.0f, 20.0f, 12.5f, 0, 0);
		chassis_move_init_f->chassis_power_pid.errorabsmin = 0.5f;
		chassis_move_init_f->chassis_power_pid.errorabsmax = 5.0f;
		

typedef struct //pid结构体变量
{
    fp32 Kp;
    fp32 Ki;
    fp32 Kd;

    fp32 max_out;  //最大输出
    fp32 max_iout; //最大积分输出

    fp32 SetValue;
    fp32 ActualValue;

    fp32 out;
	fp32 lastout;
	
    fp32 Pout;
    fp32 Iout;
    fp32 Dout;
	
	fp32 Ierror;
    fp32 Derror[3];  //微分项 0最新 1上一次 2上上次
    fp32 error[3];   //误差项 0最新 1上一次 2上上次
	
	fp32 stepIn;
	
	/* 误差死区 */
	fp32 deadband;
	
	/* 积分分离 */
    fp32 epsilon; //积分分离阈(yu)值
	
	/* 不完全微分 */
	fp32 alpha;

    /* 抗积分饱和 */
    fp32 maximum; //最大值
    fp32 minimum; //最小值

    /* 变积分 */
    fp32 errorabsmax; //偏差绝对值最大值
    fp32 errorabsmin; //偏差绝对值最小值

	/* 微分先行 */
    fp32 gama; //微分先行滤波系数
	
	pid_mode_e pid_mode;
} PidTypeDef;

float increment_pid(PidTypeDef *pid , float actualValue)
{
	//error
	pid->error[0] = pid->SetValue - actualValue;
	
	//微分项 记录
	pid->Derror[0] = pid->error[0] - 2 * pid->error[1] + pid->error[2];
	
	pid->Ierror = (pid->error[0] - pid->error[1]) / 2;
	pid->Ierror *= VariableIntegralCoefficient(pid->error[0], pid->errorabsmax, pid->errorabsmin);
	
	//输出pid运算
	pid->out = (pid->Kp * (pid->error[0] - pid->error[1])) + (pid->Ki * pid->Ierror) + (pid->Kd * pid->Derror[0]);   
	
	//PID每一项输出
	pid->Pout = (pid->Kp * (pid->error[0] - pid->error[1]));
	pid->Iout = (pid->Ki * pid->Ierror);
	pid->Dout = (pid->Kd * pid->Derror[0]);
	
	//记录error
	pid->error[2] = pid->error[1]; //记录上上次误差
	pid->error[1] = pid->error[0]; //记录上次误差
	
	return pid->out;
}


/**
  * @brief          变积分系数处理函数，实现一个输出0和1之间的分段线性函数
  * @param[in]      error: 当前输入的偏差值
  * @param[in]      absmax: 偏差绝对值的最大值
  * @param[in]      absmin: 偏差绝对值的最小值
  * @retval         factor: 控制积分的比例
  * @attention      当偏差的绝对值小于最小值时，输出为1；当偏差的绝对值大于最大值时，输出为0
  *                 当偏差的绝对值介于最大值和最小值之间时，输出在0和1之间现行变化
  */
static fp32 VariableIntegralCoefficient(fp32 error, fp32 absmax, fp32 absmin)
{
    fp32 factor = 0.0f;

    if (float_abs(error) <= absmin) //最小值
    {
        factor = 1.0f;
    }
    else if (float_abs(error) > absmax) //最大值
    {
        factor = 0.0f;
    }
    else
    {
        factor = (absmax - float_abs(error)) / (absmax - absmin);
    }

    return factor;
}
```





## 注意！！！

1. **超级电容电压不能低于12v，准备低于12v就应该做限制，不让底盘超功率运行**
2. **发送给超级电容的频率为10Hz**
3. **发送给超级电容的设定功率要先 *100，再发送，比如想设定为80w，那么就应该发送8000** 
   **`can1_cap_setmsg`函数已经在里面乘了100，所以直接发送对应的功率就好了，设定功率范围为 30~130**
4. **电源电压对超级电容影响很大，请尽量保持70%以上的电进行测试和比赛**







